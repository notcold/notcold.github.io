I"«<p>##createStoreæ–¹æ³•</p>

<p>createStore åˆ›å»º store
    subscribe reduxæ’ä»¶é€šè¿‡è¯¥æ–¹æ³•ç›‘å¬stateå˜åŒ–ï¼Œ ä¾‹å¦‚sagaç›‘å¬å¯¹åº”çš„actionæ“ä½œ</p>

<pre><code class="language-javascript">const store = createStore(
  createReducer(),
  initialState,
  composeEnhancers(...enhancers) //ä¸­é—´ä»¶
);
</code></pre>

<p>â€‹</p>

<pre><code class="language-js">
export default function createStore(reducer, preloadedState, enhancer) {
  if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') {
    enhancer = preloadedState
    preloadedState = undefined
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.')
    }
    //å­˜åœ¨applyMiddleware æ“ä½œæ—¶ï¼Œè¿›ä¸€æ­¥è°ƒç”¨applyMiddlewarå°†createStoreä¸Middlewareç»“åˆåœ¨ä¸€èµ·
    return enhancer(createStore)(reducer, preloadedState)
  }
  //...
}

    // è§‚å¯Ÿè€…æ¨¡å¼ä¼šå‘é€æ¶ˆæ¯é€šçŸ¥æ‰€æœ‰è®¢é˜…çš„æ’ä»¶
    //å°†æ‰€æœ‰çš„è®¢é˜…äº‹ä»¶ä¿å­˜
      function subscribe(listener) {
        if (typeof listener !== 'function') {
          throw new Error('Expected listener to be a function.')
        }
    
        var isSubscribed = true
    
        ensureCanMutateNextListeners()
        nextListeners.push(listener)
    
        return function unsubscribe() {
          if (!isSubscribed) {
            return
          }
    
          isSubscribed = false
    
          ensureCanMutateNextListeners()
          var index = nextListeners.indexOf(listener)
          nextListeners.splice(index, 1)
        }
      }
    
 //è¢«ä¸­é—´ä»¶åŒ…è£…   
function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(
        'Actions must be plain objects. ' +
        'Use custom middleware for async actions.'
      )
    }

    if (typeof action.type === 'undefined') {
      throw new Error(
        'Actions may not have an undefined "type" property. ' +
        'Have you misspelled a constant?'
      )
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.')
    }

    try {
      isDispatching = true
      //éå†æ‰€æœ‰çš„Reducer
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }
    //subscribeæ–¹æ³•è®¢é˜…çš„äº‹ä»¶éƒ½ä¼šè¢«æ‰§è¡Œ
    var listeners = currentListeners = nextListeners
    for (var i = 0; i &lt; listeners.length; i++) {
      listeners[i]()
    }

    return action
  }

</code></pre>

<p>##applyMiddleware
applyMiddleware æŠŠä¸­é—´ä»¶ä¸storeç»‘å®š ï¼Œå°†ä¸­é—´ä»¶çš„æ–¹æ³•ç»‘å®šåˆ°Reduxçš„dispatchä¸Š
åœ¨è°ƒç”¨çš„æ—¶å€™å°±ä¼šè§¦å‘ä¸­é—´ä»¶</p>

<pre><code class="language-javascript">const middlewares = [
  sagaMiddleware,
  routerMiddleware(history),
];

const enhancers = [
  applyMiddleware(...middlewares),
];
</code></pre>

<pre><code class="language-javascript">//æ ¸å¿ƒæ–¹æ³•ï¼Œdispatchæ–¹æ³•ä¼šè®©actionæµè¿‡æ‰€æœ‰ç»‘å®šçš„reducerï¼Œä»¥åŠapplyMiddlewareæ·»åŠ çš„ä¸­é—´ä»¶
export default function applyMiddleware(...middlewares) {
  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; {
    var store = createStore(reducer, preloadedState, enhancer)
    var dispatch = store.dispatch
    var chain = []
		//ä½œä¸ºæ‰€æœ‰ä¸­é—´ä»¶çš„ä¸Šå±‚å‚æ•°
    var middlewareAPI = {
      getState: store.getState,
      dispatch: (action) =&gt; dispatch(action)
    }
    //middleware =&gt;(middlewareAPI)=&gt;(next)=&gt; {
    // next æ˜¯ä¸Šä¸€ä¸ªæ’ä»¶
    // æ’ä»¶ä¸»ä½“ä»£ç 
    // 
    // }
    
    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    //è¢«æ‰€æœ‰ä¸­é—´ä»¶åŒ…è£…è¿‡åç”Ÿæˆçš„æ–°çš„dispatchæ–¹æ³•
    dispatch = compose(...chain)(store.dispatch)

    return {
      ...store,
      dispatch
    }
  }
}

</code></pre>

<h2 id="combinereducers">combineReducers</h2>

<p>åˆå¹¶å¤šä¸ªreducersï¼Œå¹¶è¿”å›ä¸€ä¸ªä¼šè¿”å›stateçŠ¶æ€çš„å‡½æ•°</p>

<pre><code class="language-javascript">function createReducer(injectedReducers) {
  return combineReducers({
    route: routeReducer,
    global: globalReducer
  });
}
</code></pre>

<pre><code class="language-javascript">/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */
export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers)
  const finalReducers = {}
  for (let i = 0; i &lt; reducerKeys.length; i++) {
    const key = reducerKeys[i]
    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key]
    }
  }
  const finalReducerKeys = Object.keys(finalReducers)

  // This is used to make sure we don't warn about the same
  // keys multiple times.
  let unexpectedKeyCache
  if (process.env.NODE_ENV !== 'production') {
    unexpectedKeyCache = {}
  }

  let shapeAssertionError
  try {
    assertReducerShape(finalReducers)
  } catch (e) {
    shapeAssertionError = e
  }
	//è‹¥stateä¸ºç©ºé‚£å°±æ˜¯ç¬¬ä¸€æ¬¡åˆå§‹åŒ–
  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError
    }

    let hasChanged = false
    const nextState = {}
    //éå†æ‰€æœ‰ä¼ å…¥çš„reducersæ ¹æ®ä¼ å…¥çš„stateå’Œactionç”Ÿæˆæ–°çš„stateçŠ¶æ€
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      if (typeof nextStateForKey === 'undefined') {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
  }
}
</code></pre>

:ET