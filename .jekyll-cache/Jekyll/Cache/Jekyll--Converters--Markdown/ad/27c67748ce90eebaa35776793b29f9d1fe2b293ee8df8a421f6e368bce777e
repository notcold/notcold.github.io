I"}	<h2 id="事件冒泡与事件捕获">事件冒泡与事件捕获</h2>

<p>看两段代码</p>

<p><a href="https://codepen.io/notcold/pen/XyjvzK">事件冒泡</a></p>

<pre><code class="language-html"> 
    &lt;div id="outer"&gt;
        &lt;div id="inner"&gt;Click me&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var outer = document.getElementById('outer');
        var inner = document.getElementById('inner');
        inner.addEventListener("click",function(e){
            console.log("s1 冒泡事件");
        });
        outer.addEventListener("click",function(e){
            console.log("s2 冒泡事件");
        });
    &lt;/script&gt;
    /*console 
        
        //s1 冒泡事件
        //s2 冒泡事件
    */
</code></pre>

<p><a href="https://codepen.io/notcold/pen/BGLXrM">事件捕获</a></p>

<pre><code class="language-html"> 
    &lt;div id="outer"&gt;
        &lt;div id="inner"&gt;Click me&lt;/div&gt;
    &lt;/div&gt;
    &lt;script&gt;
        var outer = document.getElementById('outer');
        var inner = document.getElementById('inner');
        inner.addEventListener("click",function(e){
            console.log("s1 事件捕获");
        },true);
        outer.addEventListener("click",function(e){
            console.log("s2 事件捕获");
        },true);
    &lt;/script&gt;
        /*console 
            
            //s2 事件捕获
            //s1 事件捕获
        */
</code></pre>

<p>从上面的例子中可以看出 <code>addEventListener</code>方法的参数可以控制事件绑定的形式。事件冒泡和事件捕获在事件触发时的执行顺序上是明显不同的。</p>

<p><!-- more --></p>

<p>在现代浏览器中，W3C标准的事件模型是先捕获再冒泡，也就是当一个元素被点击的时候，是先从根节点 <code>document</code>逐级往下直到 <code>target</code>，这是一个事件捕获的过程，这个过程中会触发路径上元素绑定的捕获事件，当到达目标元素后，测试一个冒泡的流程，事件从 <code>target</code>元素逐级向上直到 <code>document</code>根元素传递。</p>

<p>从这个模型上可以理解为事件捕获会比事件冒泡先执行，而目标元素上的事件是先绑定的先执行。</p>

<p>冒泡</p>
<pre><code>    inner -&gt; outer -&gt; document
</code></pre>

<p>捕获</p>
<pre><code>   document -&gt; outer -&gt;inner  
</code></pre>
:ET