I"}<h2 id="纯函数式">纯函数式</h2>

<p>相同的参数返回相同的结果，它的执行不依赖于系统的状态
###1. 非纯净的</p>

<pre><code class="language-js">let number = 1;

const increment = () =&gt; number += 1;

increment();
// 2
</code></pre>

<p>###2. 纯净的</p>
<pre><code class="language-js">

const increment = n =&gt; n + 1;

increment(1);
// 2
</code></pre>
<h2 id="高阶函数">高阶函数</h2>

<p>函数把其他函数当做参数传递使用或者返回一个函数</p>

<p>###1. 加法</p>

<pre><code class="language-js">const sum = (x, y) =&gt; x + y;

const calculate = (fn, x, y) =&gt; fn(x, y);

calculate(sum, 1, 2);
// 3

</code></pre>
<p>###2. filter</p>

<pre><code class="language-js">let students = [
    {name: 'Anna', score: 6},
    {name: 'John', score: 4},
    {name: 'Maria', score: 9}
];

const isApproved = student =&gt; student.score &gt;= 6;

students.filter(isApproved);
// [ { name: 'Anna', score: 6 }, { name: 'Maria', score: 9 } ]

</code></pre>
<p>###3. Map</p>

<pre><code class="language-js">const byName = obj =&gt; obj.name;

students.map(byName);
// [ 'Anna', 'John', 'Maria' ]
</code></pre>

<p>###4. 链式</p>

<pre><code class="language-js">
let students = [
    {name: 'Anna', score: 6},
    {name: 'John', score: 4},
    {name: 'Maria', score: 9}
];

const isApproved = student =&gt; student.score &gt;= 6;

const byName = obj =&gt; obj.name;

students.filter(isApproved).map(byName);
// ['Anna', 'Maria']
</code></pre>

<p>###5. Reduce</p>

<pre><code class="language-js">
const totalscores = students.reduce((sum, student) =&gt; sum + student.score, 0);

totalscores
// 19
</code></pre>
<h2 id="递归">递归</h2>

<p>当一个函数调用它自己的时候，就创造了一个循环
###1. 递减</p>

<pre><code class="language-js">const countdown = num =&gt; {
    if (num &gt; 0) {
        console.log(num);
        countdown(num - 1);
    }
}

countdown(5);
/*
5
4
3
2
1
*/
</code></pre>
<p>###2. 阶乘</p>

<pre><code class="language-js">const factorial = num =&gt; {
    if (num &lt;= 0)
    {return 1;}
    else{
        num*=factorial(num-=1)
        }
}
    factorial(5);
</code></pre>

<h2 id="functor">Functor</h2>

<p>有 map 方法的对象。functor 的 map 方法通过 map 回调函数调用自己的内容，然后返回一个新的 functor.
###1. 给数组所有的元素添加一个值</p>

<pre><code class="language-js">const plus1 = num =&gt; num + 1;

let numbers = [1, 2, 3];
numbers.map(plus1);
// [2, 3, 4]
</code></pre>

<h2 id="组合">组合</h2>

<p>通过组合两个或更多的函数生成一个新的函数
###1. 组合两个函数生成一个新的函数</p>

<pre><code class="language-js">const compose = (f,g) =&gt; x =&gt; f(g(x));

const toUpperCase = x =&gt; x.toUpperCase();
const exclaim = x =&gt; `${x}!`;

const angry = compose(exclaim, toUpperCase);

angry("stop this");
// STOP THIS!
</code></pre>

<p>###2. 组合三个函数生成一个新的</p>

<pre><code class="language-js">const compose = (f,g) =&gt; x =&gt; f(g(x));

const toUpperCase = x =&gt; x.toUpperCase();
const exclaim = x =&gt; `${x}!`;
const moreExclaim = x =&gt; `${x}!!!!!`;

const reallyAngry = compose(exclaim, compose(toUpperCase, moreExclaim));

reallyAngry("stop this");
// STOP THIS!!!!!!
</code></pre>

<h2 id="解构">解构</h2>

<p>从数组中提取数据或对象使用一种语法混合数组和对象文本的建设。或“模式匹配”。
###1. Select from pattern</p>

<pre><code class="language-js">const foo = () =&gt; [1, 2, 3];

const [a, b] = foo();
console.log(a, b);
// 1 2
</code></pre>

<p>###2. 接收 rest 值</p>

<pre><code class="language-js">const [a, ...b] = [1, 2, 3];
console.log(a, b);
// 1 [2, 3]
</code></pre>

<p>###3. 可选参数</p>

<pre><code class="language-js">const ajax = ({ url = "localhost", port: p = 80}, ...data)  =&gt;
    console.log("Url:", url, "Port:", p, "Rest:", data);

ajax({ url: "someHost" }, "additional", "data", "hello");
// Url: someHost Port: 80 Rest: [ 'additional', 'data', 'hello' ]

ajax({ }, "additional", "data", "hello");
// Url: localhost Port: 80 Rest: [ 'additional', 'data', 'hello' ]
</code></pre>

<h2 id="柯里化">柯里化</h2>

<p>一个函数有多个参数,把每个参数通过链式的形式返回下一个函数,直到最后返回结果。
###1. 对象柯里化</p>

<pre><code class="language-js">const student = name =&gt; score =&gt; `Name: ${name} | score: ${score}`;

student("Matt")(8);
// Name: Matt | score: 8
</code></pre>

<p>###2. 加法函数柯里化</p>

<pre><code class="language-js">const add = x =&gt; y =&gt; x + y;

const increment = add(1);
const addFive = add(5);

increment(3);
//4

addFive(10);
// 15
</code></pre>
:ET