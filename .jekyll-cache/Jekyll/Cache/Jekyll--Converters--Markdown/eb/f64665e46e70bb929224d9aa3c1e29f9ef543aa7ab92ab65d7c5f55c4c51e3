I"<h2 id="js-原型">js 原型</h2>

<h3 id="prototype-和proto">prototype 和<strong>proto</strong></h3>

<pre><code>prototype和__proto__是js原型的关键，他们是说明js中对象关系的特殊属性
js中只有方法才有prototype属性，普通的对象都有__proto__。
</code></pre>

<h3 id="原型链">原型链</h3>

<p>一般这么理解：访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着 <code>__proto__</code>
这条链向上找，这就是原型链。</p>

<p>ECMA 引入了标准对象原型访问器<code>Object.getPrototype(object)</code>来判断对象的原型关系</p>

<pre><code class="language-js">var func =function(){
                //this is a function
}

var obj = new Function();//用面向对象的语言解释就是 obj是类Function的一个对象，
// Function也是他的构造函数

func.__proto__.constructor.prototype === Function.prototype)
// true

// Function 的这个对象obj，它既是个对象又是个方法，js中一切皆对象（除了那个null）
obj.__proto__.constructor.prototype === Function.prototype
// true

//Function 对象本身没有toString方法，那么这个方法是从哪来的呢？
//是从Object那继承的
console.log(Function.hasOwnProperty('toString')) // false
//因为Function和Object 都是原生对象，我们无法从原型链上看到他们的关系，
// 但是js规范中规定了Function与Object的关系，也表明了js中属性的传递

console.log(Object.prototype.isPrototypeOf(Function))
//true


</code></pre>

<p>原型关系<img src="http://localhost:4000/assets/images/prototype/prototype.png" alt="图片" /></p>

<p>在 JavaScript 中，每个函数都有一个 prototype 属性，当一个函数被用作构造函数来创建实例时，
该函数的 prototype 属性值将被作为原型赋值给所有对象实例（也就是设置实例的<strong>proto</strong>属性），
也就是说，所有实例的原型引用的是函数的 prototype 属性。</p>

<p>###</p>
:ET