---
layout: post
title: babelç¼–è¯‘
description: ç¼–è¯‘æ˜¯å¦‚ä½•ç¼–è¯‘ES6ä»£ç çš„
categories:
tags: [es]
---

## babel æµç¨‹

> JavaScript çš„è¯­æ³•è¶Šæ¥è¶Šå¤æ‚ï¼Œbabel æ˜¯å¦‚ä½•æ”¯æŒ `JSX`ã€`Flow`ã€è¿˜æœ‰`Typescript`ã€‚

babel çš„æ•´ä¸ªæµç¨‹

![16d8d0cd5a3f3a0c](/Users/shikuan/Downloads/16d8d0cd559c7e1e.jpg)

**æ ¸å¿ƒæ”¯æ’‘**

- **Parser(`@babel/parser`)**ï¼š å°†æºä»£ç è§£æä¸º AST å°±é å®ƒäº†ã€‚ å®ƒå·²ç»å†…ç½®æ”¯æŒå¾ˆå¤šè¯­æ³•. ä¾‹å¦‚ JSXã€Typescriptã€Flowã€ä»¥åŠæœ€æ–°çš„ ECMAScript è§„èŒƒã€‚ç›®å‰ä¸ºäº†æ‰§è¡Œæ•ˆç‡ï¼Œparser æ˜¯[ä¸æ”¯æŒæ‰©å±•çš„](https://babeljs.io/docs/en/babel-parser#faq)ï¼Œç”±å®˜æ–¹è¿›è¡Œç»´æŠ¤ã€‚
- **Traverser(`@babel/traverse`)**ï¼š å®ç°äº†`è®¿é—®è€…æ¨¡å¼`ï¼Œå¯¹ AST è¿›è¡Œéå†ï¼Œ`è½¬æ¢æ’ä»¶`ä¼šé€šè¿‡å®ƒè·å–æ„Ÿå…´è¶£çš„ AST èŠ‚ç‚¹ï¼Œå¯¹èŠ‚ç‚¹ç»§ç»­æ“ä½œ, ä¸‹æ–‡ä¼šè¯¦ç»†ä»‹ç»`è®¿é—®å™¨æ¨¡å¼`ã€‚
- **Generator(`@babel/generator`)**ï¼š å°† AST è½¬æ¢ä¸ºæºä»£ç ï¼Œæ”¯æŒ SourceMap

â€‹ @babel/types ä¹Ÿæ˜¯æ ¸å¿ƒ å„ä¸ªè¿‡ç¨‹ä¸­å…¨éƒ¨ä¾èµ–

babel æ–¹æ³•è§£æå†…å®¹ç”Ÿæˆ AST è¯­æ³•æ ‘

```javascript
const parser = require("@babel/parser");
const ast = parser.parse("code", options);
```

å¯¹è¯­æ³•æ ‘åº”ç”¨æ’ä»¶è½¬æ¢

```javascript
//æ’ä»¶
module.exports = function () {
  return {
    name: "babel-plugin-reverse",
    visitor: {
      Identifier(path) {
        const name = path.node.name;
        console.log("name", name);
        // reverse the name: JavaScript -> tpircSavaJ
        path.node.name = name.split("").reverse().join("");
      },
    },
  };
};

// pathå¯¹è±¡åŒ…å«äº† NodeèŠ‚ç‚¹æ‰€åœ¨çš„å…¨éƒ¨ä¿¡æ¯
export class NodePath<T = Node> {
    constructor(hub: Hub, parent: Node);
    parent: Node;
    hub: Hub;
    contexts: TraversalContext[];
    data: object;
    shouldSkip: boolean;
    shouldStop: boolean;
    removed: boolean;
    state: any;
    opts: object;
    skipKeys: object;
    parentPath: NodePath;
    context: TraversalContext;
    container: object | object[];
    listKey: string; // å¦‚æœèŠ‚ç‚¹åœ¨ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œè¿™ä¸ªå°±æ˜¯èŠ‚ç‚¹æ•°ç»„çš„é”®
    inList: boolean;
    parentKey: string;
    key: string | number; // èŠ‚ç‚¹æ‰€åœ¨çš„é”®æˆ–ç´¢å¼•
    node: T;  // ğŸ”´ å½“å‰èŠ‚ç‚¹
    scope: Scope; // ğŸ”´å½“å‰èŠ‚ç‚¹æ‰€åœ¨çš„ä½œç”¨åŸŸ
    type: T extends undefined | null ? string | null : string; // ğŸ”´èŠ‚ç‚¹ç±»å‹
    typeAnnotation: object;

}


//"@babel/traverse";

//	 éå†æ–¹æ³•
export default function traverse(
  parent: Object | Array<Object>,
  opts?: Object,
  scope?: Object,
  state: Object,
  parentPath: Object,
) {
	//åˆå¹¶æ’ä»¶ï¼Œ æ”¹å˜æ•°æ®ç»“æ„ä¸º
  /**
    {
    Identifier: {
        enter: [plugin-xx, plugin-yy,] // æ•°ç»„å½¢å¼æ–¹ä¾¿è°ƒç”¨
      }
    }
  */
  visitors.explode(opts);
	// ä»ASTçš„æ ¹èŠ‚ç‚¹å¼€å§‹éå†
  // æ ¹æ®pathéå†ï¼Œpathæ ¹æ®nodeç”Ÿæˆ
  traverse.node(parent, opts, scope, state, parentPath);
}

// è¯¥æ–¹æ³•è®¿é—®å­èŠ‚ç‚¹
traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {

  //keysæ˜¯è¯¥èŠ‚ç‚¹å¯è®¿é—®çš„èŠ‚ç‚¹å±æ€§
  const keys = t.VISITOR_KEYS[node.type];
  if (!keys) return;
  const context = new _context.default(scope, opts, state, parentPath);
  for (const key of keys) {
    if (skipKeys && skipKeys[key]) continue;
    if (context.visit(node, key)) return;
  }
};


//çœç•¥ä¸­é—´æ­¥éª¤

function visit(): boolean {
  if (!this.node) {
    return false;
  }

  if (this.isBlacklisted()) {
    return false;
  }

  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
    return false;
  }

  if (this.shouldSkip || this.call("enter") || this.shouldSkip) {
    this.debug("Skip...");
    return this.shouldStop;
  }

  this.debug("Recursing into...");
  traverse.node(
    this.node,
    this.opts,
    this.scope,
    this.state,
    this,
    this.skipKeys,
  );

  this.call("exit");

  return this.shouldStop;
}

```

å°†è¢«ä¿®æ­£åçš„ AST æ ‘é‡æ–°è½¬æ¢ä¸ºä»£ç å†…å®¹

```javascript
// @babel/generator
// @flow

import type { PluginPasses } from "../../config";
import convertSourceMap, { typeof SourceMap } from "convert-source-map";
import generate from "@babel/generator";

generate(ast, opts, code);
```
