有这样一个问题：

_`我们以前去买东西的时候收银员收现金要找零，收银员有1元，2元，5元，10元，50元，100元，当我们买了东西后收银员给我们找零时哪种方法找零给的数量最少，要给几个？比如说 17元，59元，113元`_

```js
//题目的意思就是给定一个数组[1,2,5,10,50,100]，从数据中选出最少数量的值求和等于目标值
10 + 5 + 2 = 17; //3
50 + 5 + 2 + 2 = 59; //4
100 + 10 + 2 + 1 = 113; //4
```

如果我们暴力求解，对于所有的组合都计算一遍，然后比较， 那么这样的复杂度是 2 的 n 次方。

所以这种问题我们可以转换为动态规划来求解

` 动态规划是通过组合子问题的解而解决整个问题的，通过将问题分解为相互不独立（各个子问题包含有公共的子问题，也叫重叠子问题）的子问题，对每个子问题求解一次，将其结果保存到一张辅助表中，避免每次遇到各个子问题时重新计算。`

采用动态规划要满足三个基本要求：最优子结构性质、子问题重叠性、自底向上的求解方法。

### 动态规划的两个要素

1. 状态转移方程

2. 临界条件

```
	f(1) 与 f(2) 就是【边界】

	f(n) = f(n-1) + f(n-2) 就是【状态转移公式】
```

### 关键分析

用 dp[i] 来表示组成 i 块钱，需要最少的零钱数，那么

1. 第 j 个硬币我可以选择不拿 这个时候， 零钱数 = dp[i]
2. 第 j 个硬币我可以选择拿 这个时候， 零钱数 = dp[i - coins[j]] + 1

- 和背包问题不同， 找零是可以拿任意个

- 对于每一个 dp[i] 我们都选择遍历一遍 coin， 不断更新 dp[i]

| 零钱总和 | 找零组合 | 最优找零数 |
| -------- | -------- | ---------- |
| 0        | 0        | 0          |
| 2        | 2        | 1          |
| 3        | 1，2     | 2          |
| 4        | 2，2     | 2          |
| 5        | 5        | 1          |
| 6        | 5，1     | 2          |
| 7        | 5，2     | 2          |
| 8        | 5，2，1  | 3          |
| 9        | 5，2，2  | 3          |

```js
// 状态转移
// dp初始化是一个被最大数填充的数组 dp =[Number.MAX_VALUE]
//i 是总和									某个零钱
// 总和为i的零钱的方案是i与 i - coins[j] 的方案数加1
// 比如 5 与0 差5元，所以 5 的方案数是 0 的方案数加1
// 比如 6 与5 差1元，所以 6 的方案数是 5 的方案数加1
dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
```

动态规划问题要画表格，画表格的目的就是去不断推导，完成状态转移， 表格中的每一个 cell 都是一个`小问题`， 我们填表的过程其实就是在解决问题的过程，

我们先解决规模为寻常的情况，然后根据这个结果逐步推导，通常情况下，表格的右下角是问题的最大的规模，也就是我们想要求解的规模。

### 最终方案

---


title: 动态规划
description: leetcode 题目
categories: [算法]
tags:

---

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */

const change = function (coins, amount) {
  if (amount === 0) {
    return 0;
  }
  // 数字排序
  coins.sort((a, b) => a - b);
  //初始化一个数组
  const dp = Array(amount + 1).fill(Number.MAX_VALUE);
  // 0元的方案是0个，最小基准值
  dp[0] = 0;
  for (let i = 1; i < dp.length; i++) {
    for (let j = 0; j < coins.length; j++) {
      //判断总和i能否被替换入一个零钱
      if (i - coins[j] >= 0) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
      }
    }
  }

  return dp[dp.length - 1] === Number.MAX_VALUE ? -1 : dp[dp.length - 1];
};
```

### 总结

`如果说递归是从问题的结果倒推，直到问题的规模缩小到寻常。 那么动态规划就是从寻常入手， 逐步扩大规模到最优子结构。`

动态规划是从普通状态推到问题过程从而找到问题的状态转移方程，继而从一个边界开始求解，逐步推导到要求的值，跟递归和暴力破解不同的是，动态规划一般不会有很多循环，动态规划通过不停的查表从已计算出的解种不停的推导出新的解。
