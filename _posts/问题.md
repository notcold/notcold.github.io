// 实现 (5).add(3).minus(2) 功能

```
//(5).add(3).minus(2)

Number.prototype.add=function(num){
    return this.valueOf() + num
}

Number.prototype.minus=function(num){
    return this.valueOf() - num
}

```

```

// 请把两个数组 ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 和 ['A', 'B', 'C', 'D']，合并为 ['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']。

const arrMerge = (fir,sec)=>{
  let i=0
  let j=0
  const temp=[]
  while(i<fir.length&&j<sec.length){
    const a = fir[i].test(/\d/)?fir[i]:fir[i]+'3'
    const b = sec[j].test(/\d/)?sec[j]:sec[j]+'3'
    if(a<b){
      temp.push(fir[i])
      i++
    }else{
      temp.push(sec[j])
      j++
    }
  }
}

```

```
//已知如下数组：

//var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];

//编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

const flatten=(arr)=>{
  cont temp = new Set()
  const loop =(a)=>{
    a.map((item)=>{
      if(Array.isArray(item)){
        loop(item)
      }else{
         temp.add()
      }
    })
  }
  return temp.sort((a,b)=>a-b)
}

```

```

var b = 10;
(function b(){
  // 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
   // IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
    b = 20;
    console.log(b);
})();
```

```
Promise.race =function(premiseArr){
    return new Promise((resole,reject)=>{
      for(let i=0;i<premiseArr.length;i++){
        resole(premiseArr[i])
      }
    })
}
```

```

LazyMan('Tony');
// Hi I am Tony

LazyMan('Tony').sleep(10).eat('lunch');
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food


class LazyMan{
  constructer(name){
    super(name)
    this.quene = []
    console.log('Hi I am'+name)
    setTimeout(() => {
      this.next()
    })
  }

  eat(food){
    this.quene.unshift(()=>new Promise((resolve)=>{
      console.log('I am eating'+food)
      resolve()
      this.next()
    }))
    return this
  }
  sleepFirst(){
    this.quene.unshift(()=>new Promise((resolve)=>{
      setTimeout(()=>{
        console.log('等待了${time}秒...')
        resolve()
        this.next()
      },time*1000)
    }))
    return this
  }
  sleep(time){
    this.quene.push(()=>new Promise((resolve)=>{
      setTimeout(()=>{
        console.log('等待了${time}秒...')
        resolve()
        this.next()
      },time*1000)
    }))
    return this
  }
  next(){
    const fn = this.quene.shift()
    fn&&fn()
  }
}

```

